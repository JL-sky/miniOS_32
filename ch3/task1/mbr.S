;主引导程序MBR，由BIOS通过jmp 0:0x7c00跳转
 
;------------------------------------------
;vstart=0x7c00表示本程序在编译时，起始地址编译为0x7c00
SECTION MBR vstart=0x7c00
;由于BIOS是通过jmp 0:0x7c00跳转到MBR，故此时cs为0
;对于 ds、es、fs、gs 这类 sreg，CPU 中不能直接给它们赋值，没有从立即数到段寄存器的电路实现,只有通过其他寄存器来中转，这里我们用的是通用寄存器ax来中转。
    mov ax,cs
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
;初始化栈指针
    mov sp,0x7c00
;存入显存的段基址
    mov ax,0xb800
    mov gs,ax
;------------------------------------------
 
 
;------------------------------------------
;利用0x06号功能进行清屏
;INT 0x10 功能号：0x06 功能描述：上卷窗口清屏
;输入:
    ;AH 功能号：0x06
    ;AL=上卷的行数（如果为0，则表示全部）
    ;BH=上卷的行属性
    ;(CL,CH)=窗口左上角(X,Y)位置
    ;(DL,DH)=窗口右下角(X,Y)位置
;返回值
    ;无返回值
    mov ax,0x0600
    mov bx,0x0700
    mov cx,0        ;左上角(0,0)
    mov dx,0x184f   ;右下角(80,25)
                    ;0x18=24，0x4f=79
    int 0x10        ;调用BIOS中断函数
;------------------------------------------
 
;将要显示的字符串写入到显存中
    mov byte [gs:0x00],'1';在第一个字节的位置写入要显示的字符“1”
    ;在第二个字节的位置写入显示字符（也就是字符1）的属性，其中A表示绿色背景，4表示前景色为红色
    mov byte [gs:0x01],0xA4
 
    mov byte [gs:0x02],' '
    mov byte [gs:0x03],0xA4
    
    mov byte [gs:0x04],'M'
    mov byte [gs:0x05],0xA4
    
    mov byte [gs:0x06],'B'
    mov byte [gs:0x07],0xA4
 
    mov byte [gs:0x08],'R'
    mov byte [gs:0x09],0xA4
 
    jmp $
 
;times,用于指定后续数据将被重复多少次
;$表示该行指令地址，$$表示该段（section）的开始地址，因此（$-$$）表示程序总共占用的字节大小
;由于mbr程序的最后两个字节的内容（标志位0x55,0xaa）是固定的，而一个扇区总共是512字节，
;因此要把前510（512-2）个字节的内容给填满。
;故times 510-($-$$) db 0这段代码就表示用0将本扇区剩余空间进行填充
    times 510-($-$$) db 0
    db 0x55,0xaa
